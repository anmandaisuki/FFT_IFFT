# 高速フーリエ変換-逆フーリエ変換実装
高速フーリエ変換(DFT)をcppで書いてみた。

pythonのnumpyのfftと一致確認済み。

## 使い方
```
FFT(N,x[],X[]) : 入力データx[]をフーリエ変換して、X[]に入力する。データ数はNで指定。
IFFT(N,x[],X[]) :　入力データx[]を逆フーリエ変換して、X[]に入力する。データ数はNで指定。

read_txtFile(N,x[],fn[]) : テキストデータ読み込み用。FFTデバッグ用。fnで渡したファイルの中身を読んで、x[]に格納する。読み込むファイルフォーマットは下に記載。
write_txtFile(N,x[],fn[]) :FFTの結果をテキストデータに書き込む用。fnで渡したファイルにx[]を書き込む。
```
* 読み込みテキストフォーマット  
fscanfでdouble型として読み込む。デリミタ区切りで読み込んでおり、デリミタが空白でも改行でもいい。
``` 
0.0
1
2.0
3
```
```
0.0 1.0 2.0 
```

## コードの説明
* wはフーリエ変換用の回転因子、w_iは逆フーリエ用の回転因子。回転方向が時計回り、反時計回りの違い。
* 以下の第4引数はフーリエ変換か逆フーリエ変換かの指定。1でフーリエ変換、0で逆フーリエ変換。ただし、FFT(),IFFT()の関数でラップして、そこで第4引数を適切に指定するようにしてあるので、直接いじる必要はない。
``````
FFT_Butterfly_Recursion(int N, complex x[], complex X[],int dft_idft)
``````
* フーリエ変換の本体のバタフライ演算の部分は再帰処理になっており、関数の中で関数を呼び出す構造になってる。データ数が２^nとなっているので、バタフライ演算を繰り返していくうちに、1024 > 512 > ... 4 > 2となり、2になったら終わるイメージ。抽象構文木みたいな感じで枝分かれしていく感じ。
* FFT(),IFFT()の戻り値は複素数の配列なので、グラフ化するときは適切に処理する必要あり。
    * 周波数のスペクトル強度比を見たい場合は、FFTの結果を絶対値に変換する。
    ```
    |Z| = √(Re^2+Im^2)
    ```
    * 位相情報を見たいときは、tan-1を取る。
    ```
    ∠θ = tan-1(Im/Re) 
    ```
## フーリエ変換の基本
1. フーリエ変換する際は、変換前データにN/2以上の周波数（ナイキスト周波数）が入らないようにする。フーリエ変換した周波数ドメインではN/2を中心に複素共役が発生し、その複素共役の区別ができない。例えば、サンプリングレートが200kHzのとき(100kHzがナイキスト周波数)98kHzと102kHzを区別できない。98kHzの信号をフーリエ変換すると、周波数ドメイン内の98kHzと102kHzのところに複素共役の複素数が生まれる。102kHzの信号をフーリエ変換すると、同様に98kHzと102kHzに複素共役の複素数が発生する。この98kHzと102kHzに発生したシグナルを98kHzによって作られたものと102kHzによって作られたもので分離できない。

2. DFTではなくFFTを使う場合、データ数Nは2^nであること。（nは適当な数）バタフライ演算を行うため。

3. 観測範囲で周期的である場合のみ適切に周波数変換が行える。そうでない場合ノイズになる。観測窓の中で周期的ではないのに、観測範囲で周期的な波で無理やり表現しようとするのでノイズになる。関係ないところにスペクトルが立ったりする。窓関数などを用いて、強制的に窓内で周期的っぽくすることで、補正することもできる。

3. DFT自体は X[N] = [N x N] * x[N] で入力データ数に対応した行列計算を行うだけ。現実の周波数との結びつけは、データ間の時間間隔を与えることで求められる。
    * サンプリング周期(s) = A , 信号サンプリング時間(s) = Tのとき
    ```
    X[0]:(1/T)Hzの情報, 　X[1]:2*(1/T)Hzの情報 ... X[(T/2N)-1]:(T/2N)*(1/T)Hzの情報
    
    X[n]:フーリエ変換の結果
    ```
    * サンプリング周期 = 0.001s, 信号サンプリング時間 = 1sのとき（データ数1000個）
    ```
    X[0]:1Hzの信号の情報, X[1]:2Hzの信号の情報 ...X[499]:500Hzの信号の情報
    
    注:X[500]-X[999]も結果出るけど、ナイキスト周波数以上なので、無視。(X[0]-X[499]のミラー)
    注2:FFT使うならデータ数は2^nになるようにすること。実際の測定だと、サンプリング周期は変えれないことが多いため、サンプリング時間を調整したり、長時間サンプリングして、その中から2^nになるように抜き取る。
    ```

4. 観測時間Tがフーリエ変換後の周波数ドメインの分解能を決める。`1/T = 周波数ドメイン分解能。`つまり観測時間が長くなり、観測点が多くなるほど、周波数分解能はよくなる。ただしサンプリングレートが同じであれば、ナイキスト周波数は変わらないので、分解能は良くなるけど、観測周波数レンジは変わらない。100Hzのサンプリングレートで1s観測した場合は0-100Hzの周波数情報を1Hzごとに得られる。0.5s観測した場合は2-100Hzの周波数情報を2Hz毎に得られる。（つまり3Hzや5Hzは観測できない。基準になる2Hzに対して1.5倍や2.5倍で整数倍ではないから。）

5. フーリエ変換したときの、一番小さい周波数の整数倍ではない周波数は表現できない。たとえば、サンプリング時間が1sで1Hzが最小周波数のとき、1Hzの整数倍でない1.5Hzや2.5Hzの信号は適切にフーリエ変換することができない。逆に例えばサンプリング時間を2sに拡大して、最小周波数を0.5Hzにすれば、1.5Hzや2.5Hzを表現できる。サンプリング時間の拡大は低周波には影響大きいが、高周波にはあまり影響はない。1000001Hzと1000000.5Hzのように影響の割合が小さくなる。

5. イメージとして、量子力学のエネルギー離散化みたいな感じ。観測時間(窓)に対して、基準の波があって、その整数倍の周波数の波がフーリエ変換の対象になる。（つまり観測窓内で周期的になることができる。）



### その他
---
* ビットリバースのとこはかなり無理やり実装したので、他にいい方法あるかも。
* データ数Nなどの条件が固定なら、色々とインライン化（マクロで記載するとか）した方が高速化できそう。Nが決まっていれば、ビットリバースの方式も単純な変換になる。
* 多分大丈夫だと思うけど、データ数Nが2,147,483,647(int型のmax)を超えると適切に動かないかも。
